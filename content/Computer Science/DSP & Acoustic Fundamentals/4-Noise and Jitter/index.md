---
status: "published"
date: "2026-02-22"
summary: "What are the differences between noise and jitter"
---

If you have worked with DSP, or music production, you probably have seen the terms "noise" and "jitter" thrown around. But what are they exactly? And how do they differ from each other?

# 1. Noise

## 1.1. What is Noise?

The simplest way to explain it is the own definition of 'noise' - **unwanted sound**.
When you record a sound, you want it to be as perfect as possible. But in reality, whatever you're trying to record is usually surrounded by other sounds that you don't want to record. These sounds are **noise**.

Why is noise so important though? Why does it appear so much in so many areas?

The fact of it being so common is what makes it so important. Conceptually every sound we hear has some noise mixed in it. And if we want to produce any type of artifical sound that sounds realistic, we need to add some noise to it. There's no way around it. Without random fluctuations, it sounds unnatural.

## 1.2. So, how is noise defined?

We can define noise as:

> Random fluctuation in the amplitude of a signal

Yes - it's that simple. Audio waves are just amplitude values over time. So if we have some random fluctuation in the amplitude, we have noise - we introduce some randomness to the signal.

Feel free to play with the following animation to see how noise affects a signal:

<iframe src="simulations/noise.html" width="100%" height="550px"></iframe>

<br>

In mathematical terms, we can define noise as:

$$
y[s] = x[s] + n[s]
$$

Where $y[s]$ is the noisy signal, $x[s]$ is the original signal, and $n[s]$ is the noise signal. The noise signal can be anything, as long as it's random. It can be white noise, pink noise, brown noise, or any other type of noise. We will see what these "colors" mean later. 

But a spoiler - white noise is what you are most familiar with - it's the sound of static on an untuned radio.

## 1.3. White Noise - The Sound of Static

The color of noise refers to its **Power Spectral Density (PSD)** — essentially, how its energy is distributed across the frequency spectrum.

> [!NOTE]
> **A Quick Note on the "Colors" of Noise**
> 
> You might be wondering why we use colors to describe audio signals. The naming convention is actually a brilliant analogy borrowed directly from the physics of visible light!
> 
> * **White Noise:** Just like pure white light contains every color in the visible spectrum at equal intensity, white noise contains every audio frequency at equal power. 
> * **Brown (or Red) Noise:** This one has a dual origin! It is officially named **Brown noise** after botanist Robert Brown, who discovered the erratic "Brownian motion" that mathematically defines its random walk. However, acousticians also call it **Red noise**. In optics, red light sits at the absolute lowest frequency of the visible spectrum. Since this noise has its energy heavily concentrated at the lowest audio frequencies, "red" is the perfect optical equivalent.
> * **Pink Noise:** Pink sits mathematically halfway between White noise (a flat spectrum) and Red noise (a steeply falling spectrum). If you take flat white light and skew the energy toward the lower-frequency red end of the spectrum—mixing white and red—you literally get pink.


**The Math** 

White noise has equal energy per frequency (Hz). The power is constant across the entire spectrum. So at each sample *n*, the **amplitude is random and independent of the previous samples**. That is, it has absolutely **no memory of the past**:

$$
n_{white}[s] = random[s]
$$

It is basically the same as tossing a coin for each new sample. The result of current coin toss is independent of the previous coin toss.

**The Sound** 

Because human ears are more sensitive to high frequencies, and because there are mathematically way more high frequencies than low ones (there are 10,000 Hz between 10kHz and 20kHz, but only 20 Hz between 20Hz and 40Hz), white noise sounds incredibly harsh, bright, and hissy. Think of old TV static or a steam leak.


## 1.4. Brown Noise - The Sound of a Waterfall

**The Math** 

Brown noise (or red noise) is a "random walk." It is generated by taking the previous noise value and adding a tiny random change to it. In calculus, this is called integration; in DSP, it is called a running sum or an accumulator.

$$
n_{brown}[s] = \alpha \cdot n_{brown}[s-1] + random[s]
$$

The $$\alpha$$ in the formula is what we call a **persistence factor**. It determines how much of the previous value is retained in the current value. This may not be very intuitive, but if you use a value of $$1$$ for that coefficient, the random signal may grow infinitely large. That's why we use $$\alpha < 1$$, usually around $$0.99$$ to force it decrease over time, and make sure it is always near $$0$$.

**The Sound** 

Brown noise sounds like a deep, rumbling sound, similar to a waterfall or heavy rain. It is much smoother and less harsh than white noise because it has less high-frequency content.

The following animation shows how this coefficient affects the noise. You can see the orange signal going over the $$[-1, 1]$$ range, hurting the sound produced, as well as the blue signal that shows the effect of applying the persistence factor:

<iframe src="simulations/brown_noise.html" width="100%" height="700px"></iframe>

You may have noticed the lower frequencies come out more as you make the persistence factor near $$1$$. And if you make it $$0$$, you get simple white noise (as expected by the formula).


## 1.5. Pink Noise

**The Math**

Pink noise is the middle ground between white and brown noise — but not in the sense of “just pick an $$\alpha$$ somewhere in the middle.”

A single leaky integrator gives you one memory timescale. Pink noise needs something more subtle: memory at multiple scales at the same time — short memory (fast changes), medium memory, and long memory (slow drift).

So instead of one accumulator, we use a bank of leaky integrators (multiple accumulators with different persistence factors), and then mix them together:

$$
\begin{aligned}
n_i[s] &= \alpha_i \cdot n_i[s-1] + b_i \cdot \mathrm{random}[s] \\
n_{\text{pink}}[s] &= \sum_{i=1}^{k} w_i \cdot n_i[s]
\end{aligned}
$$

Where:

- $$\mathrm{random}[s]$$ is white noise (the random input)
- $$n_i[s]$$ is the output of the $$i$$-th leaky integrator
- $$\alpha_i$$ controls how long that integrator "remembers" the past
- $$w_i$$ is a weight used to balance how much that stage contributes
- $$k$$ is usually small (often 3 to 6 stages)

> [!WARNING]
> **Why not simply sum Brown noises?**
>
> Because adding several Brown-noise signals does **not** automatically produce Pink noise.
>
> A Brown-noise signal has a power slope of roughly **1/f²** (about **-6 dB per octave**).  
> If you sum multiple Brown noises, you usually still get something with the **same overall slope** — just louder or with a slightly different texture.
>
> Pink noise needs a gentler slope: **1/f** (about **-3 dB per octave**).
>
> That is why pink noise is usually built from **multiple leaky stages with different memory lengths** (different $$\alpha_i$$ values), plus **weights** to balance their contribution.
>
> In short: **Pink noise is not just “many Brown noises added together.”**  
> It is a **carefully shaped mix** of random motion across multiple time scales.

**The Intuition: "Memory at Every Scale"**

White noise has **no memory**, while Brown noise has a **lot of memory** (one long random walk).

Pink noise sits between them by combining stages that forget at different rates: one stage forgets slowly (low frequencies), another forgets faster (mid frequencies), and another forgets faster still (higher texture).

This gives the signal structure on many time scales at once. You can think of it as multiple “random motions” layered together — a slow wandering motion, a medium wobble, and a quick jitter. When balanced correctly, those layers produce the characteristic pink-noise sound.

Well then, how do we choose the $$\alpha$$ values?

Each leaky integrator has a persistence factor $$\alpha_i$$. If $$\alpha_i$$ is close to $$1$$, the stage forgets very slowly (low-frequency emphasis). If $$\alpha_i$$ is smaller, the stage forgets faster (higher-frequency contribution).

So each $$\alpha_i$$ defines a timescale. But you do not need one stage for every octave. Instead, you choose a handful of stages whose effects overlap smoothly.

A common design strategy is to pick a few target corner frequencies (spread roughly by octaves), convert each corner into an $$\alpha_i$$, and then tune the weights $$w_i$$ so the final slope approximates 1/f.

A common approximation for converting corner frequency $$f_c$$ into $$\alpha$$ (at sample rate $$f_s$$) is:

$$
\alpha \approx e^{-2\pi f_c / f_s}
$$

This gives the right behavior: low $$f_c$$ gives an $$\alpha$$ very close to $$1$$, while higher $$f_c$$ gives a smaller $$\alpha$$.

> [!IMPORTANT]
> **There is no single universal set of “pink noise alphas.”**
>
> The exact coefficients depend on:
>
> - the method used (filter bank, Voss-McCartney, etc.)
> - the sample rate
> - how accurate you want the pink slope to be
>
> That is why many implementations use slightly different “magic constants.”
> They are just tuned approximations for a good 1/f result.

**The Sound**

Pink noise sounds softer and more natural than white noise, but less heavy than brown noise.
It keeps the full-spectrum character of noise, but redistributes the energy so the highs stop dominating.
That is why it often sounds like steady rainfall, wind, distant surf, or a “room-like” ambience.
It still contains high frequencies — just not in excess.

The following simulation lets you play with the number of stages used to generate pink noise, and compares against white noise. **Important note - pink noise with 1 stage is just brown noise.**

<iframe src="simulations/pink_noise.html" width="100%" height="770px"></iframe>

===

# 2. Jitter

If noise is an error in value (the vertical Y-axis), **jitter is an error in time** (the horizontal X-axis).

When you send a signal through a pipe—whether that is an analog audio cable, a digital clock trace on a circuit board, or a TCP/IP network connection—you expect the data to travel at a consistent speed. **Jitter is the deviation from that ideal timing.**

The data itself is perfectly intact, but its arrival schedule has been corrupted.

## 2.1. The Conveyor Belt Analogy

Imagine a pristine factory conveyor belt (your pipe) delivering identical boxes (your data samples) to a worker at exactly one box per second.

- **Ideal Pipe:** The worker receives a box at exactly 1.0s, 2.0s, 3.0s, 4.0s. The flow is metronomic and perfect.
- **Jittery Pipe:** The conveyor belt motor stutters. The worker receives boxes at 1.0s, 1.9s, 3.2s, 3.8s.

None of the boxes are damaged (there is no noise), but the unpredictable delivery creates chaos for the worker trying to process them. In real-time DSP, if a sample arrives too late, the system might have nothing to play, causing an audio dropout or video stutter. If a sample arrives too early, it might get discarded because the system isn't ready for it.

## 2.2. Modeling Jitter Mathematically

To model jitter in your DSP code, you don't touch the amplitude of the signal $$x[n]$$ at all. Instead, you manipulate the delay line.

In a perfect pipe, the transit time is a constant delay, which we will call $$D$$. The output $$y[n]$$ is just the input shifted back by that exact amount of time:

$$
y[n] = x[n-D]
$$

To introduce jitter, we make that delay variable. We introduce a jitter sequence, j[n], which represents the random timing fluctuations at each step. The new equation for the pipe becomes:

$$
y[n] = x[n-(D+j[n])]
$$

Just like noise, the $$j[n]$$ sequence can take different shapes:

- **Random Jitter:** Driven by thermal physics in the hardware. The variations follow a Gaussian (bell curve) distribution.
- **Deterministic Jitter:** Predictable timing errors caused by electromagnetic interference (like a power supply humming at exactly 60 Hz) or routing flaws.

The following simulation shows how jitter works compared to noise:

<iframe src="simulations/noise_vs_jitter.html" width="100%" height="740px"></iframe>